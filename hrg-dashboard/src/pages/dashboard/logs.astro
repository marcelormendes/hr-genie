---
import DashboardLayout from "../../layouts/DashboardLayout.astro";

/* SSR auth check removed */

// Pagination parameters
const page = +(Astro.url.searchParams.get("page") || "1");
const perPage = 20;

// Filter parameters
const level = Astro.url.searchParams.get("level") || "all";
const source = Astro.url.searchParams.get("source") || "all";
const dateFrom = Astro.url.searchParams.get("from") || "";
const dateTo = Astro.url.searchParams.get("to") || "";

// Define log structure with TypeScript for client-side use
interface LogEntry {
  id: string;
  timestamp: string;
  level: string;
  source: string;
  message: string;
}

// These will be populated client-side
const uniqueSources: string[] = [];
const uniqueLevels: string[] = ["info", "warning", "error", "debug"];
---

<DashboardLayout title="Logs - HR Genie" activePage="logs">
  <h1 class="text-2xl font-bold mb-6">System Logs</h1>

  <div id="loading-indicator" class="mb-6 text-center py-4">
    <div
      class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-indigo-600"
    >
    </div>
    <p class="mt-2 text-gray-600">Loading logs...</p>
  </div>

  <div class="mb-6">
    <form
      id="filter-form"
      class="bg-white p-4 border border-gray-200 rounded-lg"
    >
      <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
        <div>
          <label
            for="level"
            class="block text-sm font-medium text-gray-700 mb-1">Level</label
          >
          <select
            id="level"
            name="level"
            class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500"
          >
            <option value="all" selected={level === "all"}>All Levels</option>
            <!-- Will be populated by JavaScript -->
          </select>
        </div>

        <div>
          <label
            for="source"
            class="block text-sm font-medium text-gray-700 mb-1">Source</label
          >
          <select
            id="source"
            name="source"
            class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500"
          >
            <option value="all" selected={source === "all"}>All Sources</option>
            <!-- Will be populated by JavaScript -->
          </select>
        </div>

        <div>
          <label for="from" class="block text-sm font-medium text-gray-700 mb-1"
            >From Date</label
          >
          <input
            type="date"
            id="from"
            name="from"
            value={dateFrom}
            class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500"
          />
        </div>

        <div>
          <label for="to" class="block text-sm font-medium text-gray-700 mb-1"
            >To Date</label
          >
          <input
            type="date"
            id="to"
            name="to"
            value={dateTo}
            class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500"
          />
        </div>
      </div>

      <div class="mt-4 flex justify-between">
        <button
          type="submit"
          class="px-4 py-2 bg-indigo-600 text-white text-sm font-medium rounded-md hover:bg-indigo-700"
        >
          Apply Filters
        </button>

        <button
          type="button"
          id="clear-filters-btn"
          class="px-4 py-2 bg-gray-100 text-gray-700 text-sm font-medium rounded-md hover:bg-gray-200"
        >
          Clear Filters
        </button>
      </div>
    </form>
  </div>

  <div class="bg-white border border-gray-200 rounded-lg overflow-hidden">
    <div class="overflow-x-auto">
      <table class="min-w-full divide-y divide-gray-200">
        <thead class="bg-gray-50">
          <tr>
            <th
              scope="col"
              class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
            >
              Timestamp
            </th>
            <th
              scope="col"
              class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
            >
              Level
            </th>
            <th
              scope="col"
              class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
            >
              Source
            </th>
            <th
              scope="col"
              class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
            >
              Message
            </th>
          </tr>
        </thead>
        <tbody id="logs-table-body" class="bg-white divide-y divide-gray-200">
          <!-- Will be populated by JavaScript -->
          <tr>
            <td colspan="4" class="px-6 py-4 text-center text-sm text-gray-500">
              Loading logs...
            </td>
          </tr>
        </tbody>
      </table>
    </div>

    <div
      id="pagination-container"
      class="px-6 py-3 border-t border-gray-200 flex items-center justify-between"
    >
      <div id="pagination-info" class="text-sm text-gray-500">Loading...</div>

      <nav id="pagination-nav" class="flex space-x-1">
        <!-- Will be populated by JavaScript -->
      </nav>
    </div>
  </div>

  <div class="mt-6 flex justify-end">
    <button
      id="export-btn"
      class="flex items-center px-4 py-2 bg-gray-100 text-gray-700 text-sm font-medium rounded-md hover:bg-gray-200"
    >
      <svg
        xmlns="http://www.w3.org/2000/svg"
        class="h-5 w-5 mr-1"
        fill="none"
        viewBox="0 0 24 24"
        stroke="currentColor"
      >
        <path
          stroke-linecap="round"
          stroke-linejoin="round"
          stroke-width="2"
          d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"
        ></path>
      </svg>
      Export Logs
    </button>
  </div>
</DashboardLayout>

<script>
  interface LogEntry {
    id: string;
    timestamp: string;
    level: string;
    source: string;
    message: string;
  }

  // Get URL parameters
  const urlParams = new URLSearchParams(window.location.search);
  let currentPage = +(urlParams.get("page") || "1");
  let currentLevel = urlParams.get("level") || "all";
  let currentSource = urlParams.get("source") || "all";
  let currentDateFrom = urlParams.get("from") || "";
  let currentDateTo = urlParams.get("to") || "";
  const perPage = 20;

  // Elements
  const loadingIndicator = document.getElementById("loading-indicator");
  const logsTableBody = document.getElementById("logs-table-body");
  const paginationContainer = document.getElementById("pagination-container");
  const paginationInfo = document.getElementById("pagination-info");
  const paginationNav = document.getElementById("pagination-nav");

  // Form elements
  const levelSelect = document.getElementById("level") as HTMLSelectElement;
  const sourceSelect = document.getElementById("source") as HTMLSelectElement;
  const filterForm = document.getElementById("filter-form");
  const clearFiltersBtn = document.getElementById("clear-filters-btn");
  const exportBtn = document.getElementById("export-btn");

  // Backend URL
  const backendUrl = import.meta.env.BACKEND_URL || "http://localhost:3000";

  // Initialize page
  document.addEventListener("DOMContentLoaded", () => {
    initializeForm();
    fetchLogs();
    setupEventListeners();
  });

  function setupEventListeners() {
    // Filter form submission
    filterForm?.addEventListener("submit", (e) => {
      e.preventDefault();
      const formData = new FormData(e.target as HTMLFormElement);
      currentLevel = formData.get("level")?.toString() || "all";
      currentSource = formData.get("source")?.toString() || "all";
      currentDateFrom = formData.get("from")?.toString() || "";
      currentDateTo = formData.get("to")?.toString() || "";
      currentPage = 1; // Reset to first page

      // Update URL
      updatePageUrl();

      // Fetch logs
      fetchLogs();
    });

    // Clear filters
    clearFiltersBtn?.addEventListener("click", () => {
      (document.getElementById("level") as HTMLSelectElement).value = "all";
      (document.getElementById("source") as HTMLSelectElement).value = "all";
      (document.getElementById("from") as HTMLInputElement).value = "";
      (document.getElementById("to") as HTMLInputElement).value = "";

      currentLevel = "all";
      currentSource = "all";
      currentDateFrom = "";
      currentDateTo = "";
      currentPage = 1;

      // Update URL and fetch logs
      updatePageUrl();
      fetchLogs();
    });

    // Export logs
    exportBtn?.addEventListener("click", exportLogs);
  }

  function updatePageUrl() {
    // Build URL params
    const params = new URLSearchParams();
    if (currentPage > 1) params.set("page", currentPage.toString());
    if (currentLevel !== "all") params.set("level", currentLevel);
    if (currentSource !== "all") params.set("source", currentSource);
    if (currentDateFrom) params.set("from", currentDateFrom);
    if (currentDateTo) params.set("to", currentDateTo);

    // Update URL without reloading the page
    const newUrl = `${window.location.pathname}${params.toString() ? "?" + params.toString() : ""}`;
    window.history.pushState({}, "", newUrl);
  }

  function initializeForm() {
    // Set initial form values from URL params
    if (levelSelect) {
      levelSelect.value = currentLevel;
    }

    if (sourceSelect) {
      sourceSelect.value = currentSource;
    }

    (document.getElementById("from") as HTMLInputElement).value =
      currentDateFrom;
    (document.getElementById("to") as HTMLInputElement).value = currentDateTo;
  }

  async function fetchFilters() {
    try {
      // Fetch sources and levels from backend
      const response = await fetch(`${backendUrl}/api/v1/logs/filters`, {
        credentials: "include",
      });

      if (!response.ok) {
        throw new Error("Failed to fetch filters");
      }

      const data = await response.json();
      const sources = data.sources || [];
      const levels = data.levels || ["info", "warning", "error", "debug"];

      // Populate source dropdown
      if (sourceSelect) {
        // Clear existing options except "All"
        while (sourceSelect.options.length > 1) {
          sourceSelect.remove(1);
        }

        // Add options
        sources.forEach((source: string) => {
          const option = document.createElement("option");
          option.value = source;
          option.textContent = source
            .split("-")
            .map((word: string) => word.charAt(0).toUpperCase() + word.slice(1))
            .join(" ");
          option.selected = currentSource === source;
          sourceSelect.appendChild(option);
        });
      }

      // Populate level dropdown
      if (levelSelect) {
        // Clear existing options except "All"
        while (levelSelect.options.length > 1) {
          levelSelect.remove(1);
        }

        // Add options
        levels.forEach((level: string) => {
          const option = document.createElement("option");
          option.value = level;
          option.textContent = level.charAt(0).toUpperCase() + level.slice(1);
          option.selected = currentLevel === level;
          levelSelect.appendChild(option);
        });
      }
    } catch (error) {
      console.error("Error fetching filters:", error);
    }
  }

  async function fetchLogs() {
    if (loadingIndicator) loadingIndicator.style.display = "block";

    try {
      // Build API URL with query parameters
      const params = new URLSearchParams();
      params.set("page", currentPage.toString());
      params.set("limit", perPage.toString());
      if (currentLevel !== "all") params.set("level", currentLevel);
      if (currentSource !== "all") params.set("source", currentSource);
      if (currentDateFrom) params.set("from", currentDateFrom);
      if (currentDateTo) params.set("to", currentDateTo);

      // Fetch logs from API
      const response = await fetch(
        `${backendUrl}/api/v1/logs?${params.toString()}`,
        {
          credentials: "include",
        }
      );

      if (!response.ok) {
        throw new Error("Failed to fetch logs");
      }

      const data = await response.json();
      const logs: LogEntry[] = data.logs || [];
      const totalLogs = data.total || 0;
      const totalPages = Math.ceil(totalLogs / perPage);

      // Populate logs table
      renderLogs(logs, totalLogs, totalPages);

      // Fetch and populate filters only on first load or after clearing
      if (sourceSelect?.options.length <= 1) {
        await fetchFilters();
      }
    } catch (error) {
      console.error("Error fetching logs:", error);
      if (logsTableBody) {
        logsTableBody.innerHTML = `
          <tr>
            <td colspan="4" class="px-6 py-4 text-center text-sm text-red-500">
              Error loading logs. Please try again later.
            </td>
          </tr>
        `;
      }
    } finally {
      if (loadingIndicator) loadingIndicator.style.display = "none";
    }
  }

  function renderLogs(logs: LogEntry[], totalLogs: number, totalPages: number) {
    if (!logsTableBody) return;

    // Clear table body
    logsTableBody.innerHTML = "";

    if (logs.length === 0) {
      logsTableBody.innerHTML = `
        <tr>
          <td colspan="4" class="px-6 py-4 text-center text-sm text-gray-500">
            No logs found matching your filters.
          </td>
        </tr>
      `;

      if (paginationContainer) {
        paginationContainer.style.display = "none";
      }

      return;
    }

    // Add log rows
    logs.forEach((log) => {
      const row = document.createElement("tr");
      row.className = "hover:bg-gray-50";

      const timestamp = new Date(log.timestamp).toLocaleString();

      row.innerHTML = `
        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
          ${timestamp}
        </td>
        <td class="px-6 py-4 whitespace-nowrap">
          <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium
            ${log.level === "info" ? "bg-blue-100 text-blue-800" : ""}
            ${log.level === "warning" ? "bg-yellow-100 text-yellow-800" : ""}
            ${log.level === "error" ? "bg-red-100 text-red-800" : ""}
            ${log.level === "debug" ? "bg-gray-100 text-gray-800" : ""}
          ">
            ${log.level}
          </span>
        </td>
        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
          ${log.source}
        </td>
        <td class="px-6 py-4 text-sm text-gray-500">
          ${log.message}
        </td>
      `;

      logsTableBody.appendChild(row);
    });

    // Update pagination info
    if (paginationInfo) {
      paginationInfo.textContent = `Showing ${(currentPage - 1) * perPage + 1} to ${Math.min(currentPage * perPage, totalLogs)} of ${totalLogs} logs`;
    }

    // Show pagination if there are multiple pages
    if (paginationContainer) {
      paginationContainer.style.display = totalPages > 1 ? "flex" : "none";

      if (totalPages > 1 && paginationNav) {
        renderPagination(totalPages);
      }
    }
  }

  function renderPagination(totalPages: number) {
    if (!paginationNav) return;

    // Clear existing pagination
    paginationNav.innerHTML = "";

    // Previous button
    const prevButton = document.createElement("a");
    prevButton.href = "#";
    prevButton.classList.add("px-3", "py-1", "rounded-md");
    prevButton.textContent = "Previous";

    if (currentPage === 1) {
      prevButton.classList.add("text-gray-300", "cursor-not-allowed");
      prevButton.setAttribute("aria-disabled", "true");
    } else {
      prevButton.classList.add("text-gray-700", "hover:bg-gray-100");
      prevButton.addEventListener("click", (e) => {
        e.preventDefault();
        if (currentPage > 1) {
          currentPage--;
          updatePageUrl();
          fetchLogs();
        }
      });
    }

    paginationNav.appendChild(prevButton);

    // Page numbers
    const pageCount = Math.min(5, totalPages);
    let startPage = 1;

    if (totalPages > 5) {
      if (currentPage <= 3) {
        startPage = 1;
      } else if (currentPage >= totalPages - 2) {
        startPage = totalPages - 4;
      } else {
        startPage = currentPage - 2;
      }
    }

    for (let i = 0; i < pageCount; i++) {
      const pageNum = startPage + i;
      const pageLink = document.createElement("a");

      pageLink.href = "#";
      pageLink.classList.add("px-3", "py-1", "rounded-md");
      pageLink.textContent = pageNum.toString();

      if (pageNum === currentPage) {
        pageLink.classList.add(
          "bg-indigo-100",
          "text-indigo-700",
          "font-medium"
        );
      } else {
        pageLink.classList.add("text-gray-700", "hover:bg-gray-100");
        pageLink.addEventListener("click", (e) => {
          e.preventDefault();
          currentPage = pageNum;
          updatePageUrl();
          fetchLogs();
        });
      }

      paginationNav.appendChild(pageLink);
    }

    // Next button
    const nextButton = document.createElement("a");
    nextButton.href = "#";
    nextButton.classList.add("px-3", "py-1", "rounded-md");
    nextButton.textContent = "Next";

    if (currentPage === totalPages) {
      nextButton.classList.add("text-gray-300", "cursor-not-allowed");
      nextButton.setAttribute("aria-disabled", "true");
    } else {
      nextButton.classList.add("text-gray-700", "hover:bg-gray-100");
      nextButton.addEventListener("click", (e) => {
        e.preventDefault();
        if (currentPage < totalPages) {
          currentPage++;
          updatePageUrl();
          fetchLogs();
        }
      });
    }

    paginationNav.appendChild(nextButton);
  }

  async function exportLogs() {
    try {
      // Build API URL with query parameters
      const params = new URLSearchParams();
      if (currentLevel !== "all") params.set("level", currentLevel);
      if (currentSource !== "all") params.set("source", currentSource);
      if (currentDateFrom) params.set("from", currentDateFrom);
      if (currentDateTo) params.set("to", currentDateTo);

      // Use fetch with blob response
      const response = await fetch(
        `${backendUrl}/api/v1/logs/export?${params.toString()}`,
        {
          credentials: "include",
        }
      );

      if (!response.ok) {
        throw new Error("Failed to export logs");
      }

      // Get file as blob
      const blob = await response.blob();

      // Create download link
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.style.display = "none";
      a.href = url;

      // Get filename from response header or use default
      const filename =
        response.headers.get("content-disposition")?.split("filename=")[1] ||
        "logs-export.csv";
      a.download = filename.replace(/['"]/g, "");

      // Trigger download
      document.body.appendChild(a);
      a.click();

      // Cleanup
      window.URL.revokeObjectURL(url);
      document.body.removeChild(a);
    } catch (error) {
      console.error("Error exporting logs:", error);
      alert("Failed to export logs. Please try again later.");
    }
  }
</script>
